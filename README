This is a git repo used to document the learning process for Spring in action.

Chapter 1:
	Spring project structure is similiar to a typical Maven or Gradle project structure, where application source code is placed under src/main/java, test code is placed under src/test/java, and non-Java resources are placed under src/main/resources.
	mvnw and mvnw.cmd: maven wrapper scripts
	pom.xml: maven build specification.
	####Application.java: Spring boot main class that bootstraps the project
	application.properties: specify configuration properties.
	static: where all static contents that serve to the browser go to. Ex. Image, CSS, JavaScript, etc.
	templates: template files that used to render content to the browser.
	######ApplicationTests.java: orginally just to ensure that Spring application content loads successfuly.
	
	Basic controller(without populating any model data):
	@Controller: an annotation primarily used to identify this class as a component for component scanning. Allow autoconfiguration creates an instance of the clas as a bean in the Spring application context. 
	@GetMapping("/"): indicates that if an HTTP GET request is received for the root path, then this method should handle that request. It does so by returning a String value of home.
	This String value is interpreted as the logical name of a view. The template name is derived from the logical view name by prefixing it with /templates/ and postfixing it with .html
	In this example here, we return home as the logical name of this view, therefore the path is /src/main/resources/templates/home.html.
	The chosen template engine is Thymeleaf. 
	
	The core Spring Framework: provides the core container and dependency injection framework, Spring MVC which can be used for REST API and HTML output, template based JDBC support, reactive-style programming. 
	
	Spring Boot: starter dependencies, autoconfiguration, the actuator which provides runtime insight into the inner workings of an application, flexible specification of environment properties, additional testing support. 
	
	Spring Data: provides the ability to define application's data repositories as simple java interface and capable of working with different kind of DBs. 
	
	Spring Security: authentication, authorization, and API secuirty. 
	
	Spring Integration and Spring Batch: help with the process of integrate with other application.
	
	Spring Cloud: cloud support.
	
	
Chapter 2:
	MVC: model view controller;
	Controller: fetch and process data.
	View: render that data into HTML that will be displayed in the broser.
	Model: similar to database. Model is an object that ferries data between a controller and whatever view is charged with rendering that data.
	data that’s placed in Model attributes is copied into the servlet response attributes, where the view can find them
	View libraries such as Thymeleaf are designed to be decoupled from any particular web framework. As such, they’re unaware of Spring’s model abstraction and are unable to work with the data that the controller places in Model . But they can work with servlet request attributes. Therefore, before Spring hands the request over to a view, it copies the model data into request attributes that Thymeleaf and other view-templating options have ready access to.
	//Thymeleaf basic: 
	//<p th:text="${message}">placeholder message</p> which will render the servlet request attribute whose key is message into HTML.
	//th:each iterates over a collection of elements, rendering the HTML once for each item in the collection
	//The <form> doesn’t declare an action attribute. This means that when the form is submitted, the browser will gather up all the data in the form and send it to the server in an HTTP POST request to the same path for which a GET request displayed the form ----the /design path.
	//Thymeleaf offers access to the Errors object via the fields property and with its th:errors attribute.
	To apply validation in Spring MVC, you need to:
		1) Declare validation rules on the class that is to be validated
		2)Specify that validation should be performed in the controller methods that
require validation
		3)Modify the form views to display validation errors.
		//handle receiving end of the POST request by the <form> 
	The @Valid annotation tells Spring MVC to perform validation on the submitted  object after it’s bound to the submitted form data and before the processDesign() method is called.
	If there are any validation errors, the details of those errors will be captured in an Errors object that’s passed into processDesign()
	when a controller is simple enough that it doesn’t populate a model or process input one can define a controller that does nothing but forward the request to a view. 
	
	Chapter 3:
	Why use JDBC or JPA:
	if not:
		too much on code that creates a connection, creates a statement, and cleans up by closing the connection, statement, and result set.
	 	any number of things could go wrong when creating the connection or the statement, or when performing the query. This requires that you catch a SQLException , which may or may not be helpful in figuring out what went wrong or how to address the problem.
		SQLException is a checked exception, which requires handling in a catch block.But the most common problems, such as failure to create a connection to the database or a mistyped query, can’t possibly be addressed in a catch block and are likely to be rethrown for handling upstream.
	
	Using JDBC:
	When persisting objects to a db, it is generally a good idea to have one field that uniquely idfentifies the object and the date and time that the object is created.
	Defining Repositories:
	figure out what operation does the given repository need to perform and write an interface class to address those methods. 
	Then write and implementation of the interface that uses JdbcTemplate to query the db.
	If there’s a file named schema.sql/data.sql in the root of the application’s classpath, then the SQL in that file will be executed against the database when the application starts. Therefore, you should place the contents of listing 3.8 in your project as a file named schema.sql in the src/main/resources folder.
	Two ways to save data with JdbcTemplate:
		Directly, using the update() method or
		Using the SimpleJdbcInsert wrapper class
	@ModelAttribute
	you can use the @ModelAttribute annotation on a method argument to access an attribute from the model or have it be instantiated if not present. The model attribute is also overlain with values from HTTP Servlet request parameters whose names match to field names. This is referred to as data binding, and it saves you from having to deal with parsing and converting individual query parameters and form fields.
	first usage: define objects which should be part of a Model
			@ModelAttribute(name = "order")
			public Order order() {
				return new Order();
			}
	second usage: have Spring MVC supply the object to a Controller method
		public String processDesign(@Valid Taco design, Errors errors, 
			@ModelAttribute Order order) {
		
			...
			Taco saved = designRepo.save(design);
			order.addDesign(saved);
			return "redirect:/orders/current";
			
			}
	
	You’ll recall that saving a taco involved not only saving the taco’s name and creation time to the Taco table, but also saving a reference to the ingredients associated with the taco to the Taco_Ingredients table. And you’ll also recall that this required you to know the Taco ’s ID, which you obtained using KeyHolder and PreparedStatementCreator .

	An equivalent yet simpler way to do it is to use simplejdbcinsert. 
	
	
	
